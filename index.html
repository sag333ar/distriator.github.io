<!DOCTYPE html>
<html>

<head>
  <!--
    If you are serving your web app in a path other than the root, change the
    href value below to reflect the base path you are serving from.

    The path provided below has to start and end with a slash "/" in order for
    it to work correctly.

    For more details:
    * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base

    This is a placeholder for base href that will be replaced by the value of
    the `--base-href` argument provided to `flutter build`.
  -->
  <base href="/" />

  <meta charset="UTF-8" />
  <meta content="IE=Edge" http-equiv="X-UA-Compatible" />
  <meta name="description" content="" />

  <!-- iOS meta tags & icons -->
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  <meta name="apple-mobile-web-app-title" content="Hive - Distriator App" />
  <link rel="apple-touch-icon" href="favicon.png" />

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="favicon.png" />

  <title>Hive - Distriator App</title>
  <link rel="manifest" href="manifest.json" />
  <style>
    .loading-indicator {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #211E32;
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      z-index: 9999;
    }

    .spinner {
      border: 4px solid rgba(0, 0, 0, 0.1);
      border-left-color: #1FC676;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }
  </style>
</head>

<body>
  <div id="loading_indicator" class="loading-indicator">
    <img src="favicon.png" alt="Loading..." width="100" /> <br/>
    <div class="spinner"></div>
    <p style="text-align: center; color: #1FC676;">Distriator is loading<br>Please wait</p>
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"
    integrity="sha512-E8QSvWZ0eCLGk4km3hxSsNmGWbLtSCSUcewDQPQWZF6pEU8GlT8a5fF32wOl1i8ftdMhssTrF/OhyGWwonTcXA=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="flutter.js"></script>
  <script
    src="packages/hive_flutter_kit/web/hiveflutterkit.js"
    type="application/javascript"
    defer
    async
  ></script>

  <!-- <script>
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker
        .register("flutter_service_worker.js")
        .then(function (registration) {
          registration.addEventListener("updatefound", function () {
            const installingWorker = registration.installing;

            installingWorker.addEventListener("statechange", function () {
              if (
                installingWorker.state === "installed" &&
                navigator.serviceWorker.controller
              ) {
                // Notify the app that a new version is available
                window.dispatchEvent(new Event("new-content-available"));
              }
            });
          });
        });
    }
  </script> -->

  <script>
    async function getPermissions() {
      return new Promise((resolve, reject) => {
        window.navigator.getUserMedia(
          { audio: true, video: true },
          () => resolve("success"),
          (e) => resolve(e.toString())
        );
      });
    }

    async function evaluateJavaScript(jsCode) {
      const response = await eval(jsCode);
      return replyToNative({
        data: response,
        valid: true,
        error: "",
      });
    }

    function getDecryptedData(data, rKey) {
      const result = CryptoJS.AES.decrypt(data, rKey).toString(
        CryptoJS.enc.Utf8
      );
      return result;
    }

  </script>
  <script>
    async function getAccountHistory(accountName, startId, limit, filters) {
      const op = window.dhiveUtils.operationOrders;
      const operationsBitmask = window.dhiveUtils.makeBitMaskFilter([op.transfer]);
      const response = await window.dhiveClient.database.getAccountHistory(
        accountName,
        startId,
        limit,
        operationsBitmask
      );
      return replyToNative({
        data: response,
        valid: true,
        error: "",
      });
    }

    async function getAccountIncomeExpense(
      accountName,
      startId,
      limit,
      nameOfBusinesses
    ) {
      const op = window.dhiveUtils.operationOrders;
      const operationsBitmask = window.dhiveUtils.makeBitMaskFilter([op.transfer]);
      let response = await window.dhiveClient.database.getAccountHistory(
        accountName,
        startId,
        limit,
        operationsBitmask
      );
      response = response.filter((item) => {
        let operation = item[1];
        if (operation.op[1].from === "thedistriator") {
          return true;
        }
        if (
          nameOfBusinesses.includes(operation.op[1].to) &&
          (operation.op[1].memo.includes("v4v-") ||
            operation.op[1].memo.includes("kcs-"))
        ) {
          return true;
        }
      });
      return replyToNative({
        data: response,
        valid: true,
        error: "",
      });
    }

    function injectGoogleMapsTag(key) {
      var script = document.createElement("script");
      script.setAttribute(
        "src",
        `https://maps.googleapis.com/maps/api/js?key=${key}`
      );
      script.setAttribute("async", "");
      script.setAttribute("defer", "");
      document.head.appendChild(script);
    }

    function replyToNative(result) {
      return JSON.stringify(result);
    }
  </script>
  <script>
    window.addEventListener("load", function (ev) {
      // Download main.dart.js
      _flutter.loader.loadEntrypoint({
        onEntrypointLoaded: function (engineInitializer) {
          engineInitializer.initializeEngine().then(function (appRunner) {
            appRunner.runApp().then(function (app) {
              // Hide the loading indicator
              document.getElementById("loading_indicator").style.display = "none";
            });
          });
        },
      });
    });

    async function getFormattedSpendHistory(username, filterDays) {
  try {
    // Calculate filter date (current date - filterDays)
    const currentDate = new Date();
    const filterTimestamp = new Date();
    filterTimestamp.setDate(currentDate.getDate() - filterDays);

    let transactions = [];
    let lastId = -1;
    const limit = 1000; // Maximum records per request
    let hasMoreData = true;

    while (hasMoreData) {
      // Fetch account history with pagination
      const history = await window.dhiveClient.database.call('get_account_history', [username, lastId, limit]);
      
      if (history.length <= 1) {
        // No more data to fetch
        hasMoreData = false;
        break;
      }

      const newTransactions = history
        .map(entry => entry[1]) // Extract transaction details
        .filter(tx => {
          const txDate = new Date(tx.timestamp);
          return (
            tx.op[0] === 'transfer' &&
            tx.op[1].from === 'thedistriator' &&
            tx.op[1].memo.startsWith("You claimed back") &&
            txDate >= filterTimestamp // Ensure transaction is within filterDays
          );
        })
        .map(tx => {
          const details = tx.op[1];

          // Extract cashback amount and timestamp
          const cashback = details.amount; // Cashback is the transfer amount
          const timestamp = tx.timestamp;
          const memo = details.memo || '';

          let cashbackPercent = '0.00 %';
          let spendingAmount = '0.000 HBD';
          let businessName = '';

          // Extract cashback percentage
          const cashbackMatch = memo.match(/You claimed back (\d+(\.\d+)?) %/);
          if (cashbackMatch) {
            cashbackPercent = `${cashbackMatch[1]} %`;
            const cashbackValue = parseFloat(cashback.split(' ')[0]); // Convert cashback to number
            const percentValue = parseFloat(cashbackMatch[1]);

            if (percentValue > 0) {
              spendingAmount = `${(cashbackValue / percentValue * 100).toFixed(3)} HBD`;
            }
          }

          // Extract business name (between "a" and "-")
          const businessMatch = memo.match(/(?<=& adding review of )(.*?)(?= - https:\/\/)/);
          if (businessMatch) {
            businessName = businessMatch[1];
          }

          return {
            cashback,
            cashbackPercent,
            spendingAmount,
            trxnTs: timestamp,
            country: "",
            city: "",
            state: "",
            businessName
          };
        });

      transactions = [...transactions, ...newTransactions];

      // Update lastId for next iteration
      // Get the first transaction's ID from the current batch
      if (history.length > 0) {
        lastId = history[0][0]; // First entry's ID
        
        // If we've reached very old transactions before the filter date, stop
        const oldestTxInBatch = new Date(history[history.length - 1][1].timestamp);
        if (oldestTxInBatch < filterTimestamp) {
          hasMoreData = false;
        }
      }

      // Add a small delay to avoid rate limiting
      await new Promise(resolve => setTimeout(resolve, 100));
    }

    console.log("Total transactions Data", transactions);
    console.log("Total transactions found:", transactions.length);
    return transactions;

  } catch (error) {
    console.error('Error fetching account history:', error);
    throw error;
  }
}

  // Add JS bridge for Flutter to call scroll message
  function sendScrollMessageToFlutter() {
    window.location.reload();
  }

  async function distriatorBroadcastOperationWithPrivatePostingKey(operations, privateKey) {
    console.log(`Dhive is ${window.dhive}`);
    console.log(`Dhive PK is ${window.dhive.PrivateKey}`);
    const postingKey = window.dhive.PrivateKey.fromString(privateKey);
    // const jsonString = atob(operations);
    operations = JSON.parse(operations);
    try {
      const result = await window.dhiveClient.broadcast.sendOperations(operations, postingKey);
      console.log('✅ Broadcast successful:', result);
      return JSON.stringify(result);
    } catch (error) {
      console.error('❌ Broadcast failed:', error);
      return JSON.stringify({ error: error.toString() });
    }
  }

  </script>
  <script src="flutter.js" defer></script>
</body>

</html>